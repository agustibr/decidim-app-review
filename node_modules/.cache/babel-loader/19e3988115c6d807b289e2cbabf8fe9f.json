{"ast":null,"code":"import AutoComplete from \"src/decidim/autocomplete\";\n/**\n * This function can be used to create an autocomplete input automatically\n * from the following kind of div:\n *   <div data-autocomplete=\"{...}\"></div>\n *\n * The data-autocomplete attribute should contain the following configuration\n * as an encoded JSON, which is used to generate the AutoComplete options:\n * - name: assembly_member[user_id],\n * - options: [],\n * - placeholder: \"Select a participant\",\n * - searchURL: \"http://...\"\n * - selected: \"\",\n *\n * @param {HTMLElement} el The element to generate the autocomplete for.\n * @returns {AutoComplete} An instance of the AutoComplete class.\n */\n\nvar autoConfigure = function autoConfigure(el) {\n  var config = JSON.parse(el.dataset.autocomplete);\n  var textInput = document.createElement(\"input\");\n  textInput.type = \"text\";\n  textInput.className = \"autocomplete-input\";\n  el.appendChild(textInput);\n  var mode = config.mode || \"sticky\";\n  var selected = null;\n\n  if (config.selected) {\n    switch (mode) {\n      case \"multi\":\n        selected = config.selected.map(function (item) {\n          return {\n            key: \"label\",\n            value: {\n              value: item.value,\n              label: item.label\n            }\n          };\n        });\n        break;\n\n      case \"sticky\":\n        selected = {\n          key: \"label\",\n          value: config.options[config.options.length - 1]\n        };\n        break;\n\n      default:\n        selected = config.selected;\n    }\n  }\n\n  var dataSource = function dataSource(query, callback) {\n    var params = new URLSearchParams({\n      term: query\n    });\n    fetch(\"\".concat(config.searchURL, \"?\").concat(params.toString()), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }).then(function (response) {\n      return response.json();\n    }).then(function (data) {\n      callback(data);\n    });\n  };\n\n  var ac = new AutoComplete(textInput, {\n    name: config.name,\n    placeholder: config.placeholder,\n    selected: selected,\n    mode: mode,\n    searchPrompt: true,\n    searchPromptText: config.searchPromptText,\n    threshold: 3,\n    dataMatchKeys: [\"label\"],\n    dataSource: dataSource\n  });\n  return ac;\n};\n\n$(function () {\n  var $autocompleteDiv = $(\"[data-autocomplete]\");\n\n  if ($autocompleteDiv.length < 1) {\n    return;\n  }\n\n  $autocompleteDiv.each(function (_index, element) {\n    autoConfigure(element);\n  });\n});","map":{"version":3,"mappings":"AAAA,OAAOA,YAAP,MAAyB,0BAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,EAAD,EAAQ;EAC5B,IAAMC,MAAM,GAAGC,IAAI,CAACC,KAALD,CAAWF,EAAE,CAACI,OAAHJ,CAAWK,YAAtBH,CAAf;EACA,IAAMI,SAAS,GAAGC,QAAQ,CAACC,aAATD,CAAuB,OAAvBA,CAAlB;EACAD,SAAS,CAACG,IAAVH,GAAiB,MAAjBA;EACAA,SAAS,CAACI,SAAVJ,GAAsB,oBAAtBA;EACAN,EAAE,CAACW,WAAHX,CAAeM,SAAfN;EACA,IAAIY,IAAI,GAAGX,MAAM,CAACW,IAAPX,IAAe,QAA1B;EACA,IAAIY,QAAQ,GAAG,IAAf;;EACA,IAAIZ,MAAM,CAACY,QAAX,EAAqB;IACnB,QAAQD,IAAR;MACA,KAAK,OAAL;QACEC,QAAQ,GAAGZ,MAAM,CAACY,QAAPZ,CAAgBa,GAAhBb,CAAoB,UAACc,IAAD;UAAA,OAC7B;YACEC,GAAG,EAAE,OADP;YAEEC,KAAK,EAAE;cACLA,KAAK,EAAEF,IAAI,CAACE,KADP;cAELC,KAAK,EAAEH,IAAI,CAACG;YAFP;UAFT,CAD6B;QAApB,EAAXL;QASA;;MACF,KAAK,QAAL;QACEA,QAAQ,GAAG;UAAEG,GAAG,EAAE,OAAP;UAAgBC,KAAK,EAAEhB,MAAM,CAACkB,OAAPlB,CAAeA,MAAM,CAACkB,OAAPlB,CAAemB,MAAfnB,GAAwB,CAAvCA;QAAvB,CAAXY;QACA;;MACF;QACEA,QAAQ,GAAGZ,MAAM,CAACY,QAAlBA;IAhBF;EAkBD;;EAED,IAAMQ,UAAU,GAAG,SAAbA,UAAa,CAACC,KAAD,EAAQC,QAAR,EAAqB;IACtC,IAAMC,MAAM,GAAG,IAAIC,eAAJ,CAAoB;MAAEC,IAAI,EAAEJ;IAAR,CAApB,CAAf;IACAK,KAAK,WAAI1B,MAAM,CAAC2B,SAAX,cAAwBJ,MAAM,CAACK,QAAPL,EAAxB,GAA6C;MAChDM,MAAM,EAAE,KADwC;MAEhDC,OAAO,EAAE;QAAE,gBAAgB;MAAlB;IAFuC,CAA7C,CAALJ,CAGGK,IAHHL,CAGQ,UAACM,QAAD;MAAA,OAAcA,QAAQ,CAACC,IAATD,EAAd;IAHR,GAGuCD,IAHvCL,CAG4C,UAACQ,IAAD,EAAU;MACpDZ,QAAQ,CAACY,IAAD,CAARZ;IAJF;EAFF;;EAUA,IAAMa,EAAE,GAAG,IAAItC,YAAJ,CAAiBQ,SAAjB,EAA4B;IACrC+B,IAAI,EAAEpC,MAAM,CAACoC,IADwB;IAErCC,WAAW,EAAErC,MAAM,CAACqC,WAFiB;IAGrCzB,QAAQ,EAAEA,QAH2B;IAIrCD,IAAI,EAAEA,IAJ+B;IAKrC2B,YAAY,EAAE,IALuB;IAMrCC,gBAAgB,EAAEvC,MAAM,CAACuC,gBANY;IAOrCC,SAAS,EAAE,CAP0B;IAQrCC,aAAa,EAAE,CAAC,OAAD,CARsB;IASrCrB,UAAU,EAAVA;EATqC,CAA5B,CAAX;EAYA,OAAOe,EAAP;AAnDF;;AAsDAO,CAAC,CAAC,YAAM;EACN,IAAMC,gBAAgB,GAAGD,CAAC,CAAC,qBAAD,CAA1B;;EACA,IAAIC,gBAAgB,CAACxB,MAAjBwB,GAA0B,CAA9B,EAAiC;IAC/B;EACD;;EAEDA,gBAAgB,CAACC,IAAjBD,CAAsB,UAACE,MAAD,EAASC,OAAT,EAAqB;IACzChD,aAAa,CAACgD,OAAD,CAAbhD;EADF;AAND,EAAD4C","names":["AutoComplete","autoConfigure","el","config","JSON","parse","dataset","autocomplete","textInput","document","createElement","type","className","appendChild","mode","selected","map","item","key","value","label","options","length","dataSource","query","callback","params","URLSearchParams","term","fetch","searchURL","toString","method","headers","then","response","json","data","ac","name","placeholder","searchPrompt","searchPromptText","threshold","dataMatchKeys","$","$autocompleteDiv","each","_index","element"],"sources":["/home/agustibr/.asdf/installs/ruby/3.0.2/lib/ruby/gems/3.0.0/bundler/gems/decidim-a25b5c74f78d/decidim-admin/app/packs/src/decidim/admin/admin_autocomplete.js"],"sourcesContent":["import AutoComplete from \"src/decidim/autocomplete\";\n\n/**\n * This function can be used to create an autocomplete input automatically\n * from the following kind of div:\n *   <div data-autocomplete=\"{...}\"></div>\n *\n * The data-autocomplete attribute should contain the following configuration\n * as an encoded JSON, which is used to generate the AutoComplete options:\n * - name: assembly_member[user_id],\n * - options: [],\n * - placeholder: \"Select a participant\",\n * - searchURL: \"http://...\"\n * - selected: \"\",\n *\n * @param {HTMLElement} el The element to generate the autocomplete for.\n * @returns {AutoComplete} An instance of the AutoComplete class.\n */\nconst autoConfigure = (el) => {\n  const config = JSON.parse(el.dataset.autocomplete);\n  const textInput = document.createElement(\"input\");\n  textInput.type = \"text\";\n  textInput.className = \"autocomplete-input\";\n  el.appendChild(textInput);\n  let mode = config.mode || \"sticky\"\n  let selected = null;\n  if (config.selected) {\n    switch (mode) {\n    case \"multi\":\n      selected = config.selected.map((item) => (\n        {\n          key: \"label\",\n          value: {\n            value: item.value,\n            label: item.label\n          }\n        }\n      ));\n      break;\n    case \"sticky\":\n      selected = { key: \"label\", value: config.options[config.options.length - 1] };\n      break;\n    default:\n      selected = config.selected;\n    }\n  }\n\n  const dataSource = (query, callback) => {\n    const params = new URLSearchParams({ term: query });\n    fetch(`${config.searchURL}?${params.toString()}`, {\n      method: \"GET\",\n      headers: { \"Content-Type\": \"application/json\" }\n    }).then((response) => response.json()).then((data) => {\n      callback(data)\n    });\n  };\n\n  const ac = new AutoComplete(textInput, {\n    name: config.name,\n    placeholder: config.placeholder,\n    selected: selected,\n    mode: mode,\n    searchPrompt: true,\n    searchPromptText: config.searchPromptText,\n    threshold: 3,\n    dataMatchKeys: [\"label\"],\n    dataSource\n  });\n\n  return ac;\n}\n\n$(() => {\n  const $autocompleteDiv = $(\"[data-autocomplete]\");\n  if ($autocompleteDiv.length < 1) {\n    return;\n  }\n\n  $autocompleteDiv.each((_index, element) => {\n    autoConfigure(element);\n  })\n})\n"]},"metadata":{},"sourceType":"module"}