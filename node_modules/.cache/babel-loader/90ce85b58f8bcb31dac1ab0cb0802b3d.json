{"ast":null,"code":"/* eslint-disable */\n\n/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n;\n\n(function (jQuery, undefined) {\n  var oldManip = jQuery.fn.domManip,\n      tmplItmAtt = \"_tmplitem\",\n      htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n      newTmplItems = {},\n      wrappedItems = {},\n      appendToTmplItems,\n      topTmplItem = {\n    key: 0,\n    data: {}\n  },\n      itemKey = 0,\n      cloneIndex = 0,\n      stack = [];\n\n  function newTmplItem(options, parentItem, fn, data) {\n    // Returns a template item data structure for a new rendered instance of a template (a 'template item').\n    // The content field is a hierarchical array of strings and nested items (to be\n    // removed and replaced by nodes field of dom elements, once inserted in DOM).\n    var newItem = {\n      data: data || (parentItem ? parentItem.data : {}),\n      _wrap: parentItem ? parentItem._wrap : null,\n      tmpl: null,\n      parent: parentItem || null,\n      nodes: [],\n      calls: tiCalls,\n      nest: tiNest,\n      wrap: tiWrap,\n      html: tiHtml,\n      update: tiUpdate\n    };\n\n    if (options) {\n      jQuery.extend(newItem, options, {\n        nodes: [],\n        parent: parentItem\n      });\n    }\n\n    if (fn) {\n      // Build the hierarchical content to be used during insertion into DOM\n      newItem.tmpl = fn;\n      newItem._ctnt = newItem._ctnt || newItem.tmpl(jQuery, newItem);\n      newItem.key = ++itemKey; // Keep track of new template item, until it is stored as jQuery Data on DOM element\n\n      (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n    }\n\n    return newItem;\n  } // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n\n\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var ret = [],\n          insert = jQuery(selector),\n          elems,\n          i,\n          l,\n          tmplItems,\n          parent = this.length === 1 && this[0].parentNode;\n      appendToTmplItems = newTmplItems || {};\n\n      if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {\n        insert[original](this[0]);\n        ret = this;\n      } else {\n        for (i = 0, l = insert.length; i < l; i++) {\n          cloneIndex = i;\n          elems = (i > 0 ? this.clone(true) : this).get();\n          jQuery.fn[original].apply(jQuery(insert[i]), elems);\n          ret = ret.concat(elems);\n        }\n\n        cloneIndex = 0;\n        ret = this.pushStack(ret, name, insert.selector);\n      }\n\n      tmplItems = appendToTmplItems;\n      appendToTmplItems = null;\n      jQuery.tmpl.complete(tmplItems);\n      return ret;\n    };\n  });\n  jQuery.fn.extend({\n    // Use first wrapped element as template markup.\n    // Return wrapped set of template items, obtained by rendering template against data.\n    tmpl: function tmpl(data, options, parentItem) {\n      return jQuery.tmpl(this[0], data, options, parentItem);\n    },\n    // Find which rendered template item the first wrapped DOM element belongs to\n    tmplItem: function tmplItem() {\n      return jQuery.tmplItem(this[0]);\n    },\n    // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n    template: function template(name) {\n      return jQuery.template(name, this[0]);\n    },\n    domManip: function domManip(args, table, callback, options) {\n      // This appears to be a bug in the appendTo, etc. implementation\n      // it should be doing .call() instead of .apply(). See #6227\n      if (args[0] && args[0].nodeType) {\n        var dmArgs = jQuery.makeArray(arguments),\n            argsLength = args.length,\n            i = 0,\n            tmplItem;\n\n        while (i < argsLength && !(tmplItem = jQuery.data(args[i++], \"tmplItem\"))) {}\n\n        if (argsLength > 1) {\n          dmArgs[0] = [jQuery.makeArray(args)];\n        }\n\n        if (tmplItem && cloneIndex) {\n          dmArgs[2] = function (fragClone) {\n            // Handler called by oldManip when rendered template has been inserted into DOM.\n            jQuery.tmpl.afterManip(this, fragClone, callback);\n          };\n        }\n\n        oldManip.apply(this, dmArgs);\n      } else {\n        oldManip.apply(this, arguments);\n      }\n\n      cloneIndex = 0;\n\n      if (!appendToTmplItems) {\n        jQuery.tmpl.complete(newTmplItems);\n      }\n\n      return this;\n    }\n  });\n  jQuery.extend({\n    // Return wrapped set of template items, obtained by rendering template against data.\n    tmpl: function tmpl(_tmpl, data, options, parentItem) {\n      var ret,\n          topLevel = !parentItem;\n\n      if (topLevel) {\n        // This is a top-level tmpl call (not from a nested template using {{tmpl}})\n        parentItem = topTmplItem;\n        _tmpl = jQuery.template[_tmpl] || jQuery.template(null, _tmpl);\n        wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n      } else if (!_tmpl) {\n        // The template item is already associated with DOM - this is a refresh.\n        // Re-evaluate rendered template for the parentItem\n        _tmpl = parentItem.tmpl;\n        newTmplItems[parentItem.key] = parentItem;\n        parentItem.nodes = [];\n\n        if (parentItem.wrapped) {\n          updateWrapped(parentItem, parentItem.wrapped);\n        } // Rebuild, without creating a new template item\n\n\n        return jQuery(build(parentItem, null, parentItem.tmpl(jQuery, parentItem)));\n      }\n\n      if (!_tmpl) {\n        return []; // Could throw...\n      }\n\n      if (typeof data === \"function\") {\n        data = data.call(parentItem || {});\n      }\n\n      if (options && options.wrapped) {\n        updateWrapped(options, options.wrapped);\n      }\n\n      ret = jQuery.isArray(data) ? jQuery.map(data, function (dataItem) {\n        return dataItem ? newTmplItem(options, parentItem, _tmpl, dataItem) : null;\n      }) : [newTmplItem(options, parentItem, _tmpl, data)];\n      return topLevel ? jQuery(build(parentItem, null, ret)) : ret;\n    },\n    // Return rendered template item for an element.\n    tmplItem: function tmplItem(elem) {\n      var tmplItem;\n\n      if (elem instanceof jQuery) {\n        elem = elem[0];\n      }\n\n      while (elem && elem.nodeType === 1 && !(tmplItem = jQuery.data(elem, \"tmplItem\")) && (elem = elem.parentNode)) {}\n\n      return tmplItem || topTmplItem;\n    },\n    // Set:\n    // Use $.template( name, tmpl ) to cache a named template,\n    // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n    // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n    // Get:\n    // Use $.template( name ) to access a cached template.\n    // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n    // will return the compiled template, without adding a name reference.\n    // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n    // to $.template( null, templateString )\n    template: function template(name, tmpl) {\n      if (tmpl) {\n        // Compile template and associate with name\n        if (typeof tmpl === \"string\") {\n          // This is an HTML string being passed directly in.\n          tmpl = buildTmplFn(tmpl);\n        } else if (tmpl instanceof jQuery) {\n          tmpl = tmpl[0] || {};\n        }\n\n        if (tmpl.nodeType) {\n          // If this is a template block, use cached copy, or generate tmpl function and cache.\n          tmpl = jQuery.data(tmpl, \"tmpl\") || jQuery.data(tmpl, \"tmpl\", buildTmplFn(tmpl.innerHTML));\n        }\n\n        return typeof name === \"string\" ? jQuery.template[name] = tmpl : tmpl;\n      } // Return named compiled template\n\n\n      return name ? typeof name !== \"string\" ? jQuery.template(null, name) : jQuery.template[name] || // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\n      jQuery.template(null, htmlExpr.test(name) ? name : jQuery(name)) : null;\n    },\n    encode: function encode(text) {\n      // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n      return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n    }\n  });\n  jQuery.extend(jQuery.tmpl, {\n    tag: {\n      \"tmpl\": {\n        _default: {\n          $2: \"null\"\n        },\n        open: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\" // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n        // This means that {{tmpl foo}} treats foo as a template (which IS a function).\n        // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n\n      },\n      \"wrap\": {\n        _default: {\n          $2: \"null\"\n        },\n        open: \"$item.calls(_,$1,$2);_=[];\",\n        close: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n      },\n      \"each\": {\n        _default: {\n          $2: \"$index, $value\"\n        },\n        open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n        close: \"}});}\"\n      },\n      \"if\": {\n        open: \"if(($notnull_1) && $1a){\",\n        close: \"}\"\n      },\n      \"else\": {\n        _default: {\n          $1: \"true\"\n        },\n        open: \"}else if(($notnull_1) && $1a){\"\n      },\n      \"html\": {\n        // Unecoded expression evaluation.\n        open: \"if($notnull_1){_.push($1a);}\"\n      },\n      \"=\": {\n        // Encoded expression evaluation. Abbreviated form is ${}.\n        _default: {\n          $1: \"$data\"\n        },\n        open: \"if($notnull_1){_.push($.encode($1a));}\"\n      },\n      \"!\": {\n        // Comment tag. Skipped by parser\n        open: \"\"\n      }\n    },\n    // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n    complete: function complete(items) {\n      newTmplItems = {};\n    },\n    // Call this from code which overrides domManip, or equivalent\n    // Manage cloning/storing template items etc.\n    afterManip: function afterManip(elem, fragClone, callback) {\n      // Provides cloned fragment ready for fixup prior to and after insertion into DOM\n      var content = fragClone.nodeType === 11 ? jQuery.makeArray(fragClone.childNodes) : fragClone.nodeType === 1 ? [fragClone] : []; // Return fragment to original caller (e.g. append) for DOM insertion\n\n      callback.call(elem, fragClone); // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n\n      storeTmplItems(content);\n      cloneIndex++;\n    }\n  }); //========================== Private helper functions, used by code above ==========================\n\n  function build(tmplItem, nested, content) {\n    // Convert hierarchical content into flat string array\n    // and finally return array of fragments ready for DOM insertion\n    var frag,\n        ret = content ? jQuery.map(content, function (item) {\n      return typeof item === \"string\" ? // Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n      tmplItem.key ? item.replace(/(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\") : item : // This is a child template item. Build nested template.\n      build(item, tmplItem, item._ctnt);\n    }) : // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n    tmplItem;\n\n    if (nested) {\n      return ret;\n    } // top-level template\n\n\n    ret = ret.join(\"\"); // Support templates which have initial or final text nodes, or consist only of text\n    // Also support HTML entities within the HTML markup.\n\n    ret.replace(/^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function (all, before, middle, after) {\n      frag = jQuery(middle).get();\n      storeTmplItems(frag);\n\n      if (before) {\n        frag = unencode(before).concat(frag);\n      }\n\n      if (after) {\n        frag = frag.concat(unencode(after));\n      }\n    });\n    return frag ? frag : unencode(ret);\n  }\n\n  function unencode(text) {\n    // Use createElement, since createTextNode will not render HTML entities correctly\n    var el = document.createElement(\"div\");\n    el.innerHTML = text;\n    return jQuery.makeArray(el.childNodes);\n  } // Generate a reusable function that will serve to render a template against data\n\n\n  function buildTmplFn(markup) {\n    return new Function(\"jQuery\", \"$item\", \"var $=jQuery,call,_=[],$data=$item.data;\" + // Introduce the data as local variables using with(){}\n    \"with($data){_.push('\" + // Convert the template into pure JavaScript\n    jQuery.trim(markup).replace(/([\\\\'])/g, \"\\\\$1\").replace(/[\\r\\t\\n]/g, \" \").replace(/\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\").replace(/\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g, function (all, slash, type, fnargs, target, parens, args) {\n      var tag = jQuery.tmpl.tag[type],\n          def,\n          expr,\n          exprAutoFnDetect;\n\n      if (!tag) {\n        throw \"Template command not found: \" + type;\n      }\n\n      def = tag._default || [];\n\n      if (parens && !/\\w$/.test(target)) {\n        target += parens;\n        parens = \"\";\n      }\n\n      if (target) {\n        target = unescape(target);\n        args = args ? \",\" + unescape(args) + \")\" : parens ? \")\" : \"\"; // Support for target being things like a.toLowerCase();\n        // In that case don't call with template item as 'this' pointer. Just evaluate...\n\n        expr = parens ? target.indexOf(\".\") > -1 ? target + parens : \"(\" + target + \").call($item\" + args : target;\n        exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n      } else {\n        exprAutoFnDetect = expr = def.$1 || \"null\";\n      }\n\n      fnargs = unescape(fnargs);\n      return \"');\" + tag[slash ? \"close\" : \"open\"].split(\"$notnull_1\").join(target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\").split(\"$1a\").join(exprAutoFnDetect).split(\"$1\").join(expr).split(\"$2\").join(fnargs ? fnargs.replace(/\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function (all, name, parens, params) {\n        params = params ? \",\" + params + \")\" : parens ? \")\" : \"\";\n        return params ? \"(\" + name + \").call($item\" + params : all;\n      }) : def.$2 || \"\") + \"_.push('\";\n    }) + \"');}return _;\");\n  }\n\n  function updateWrapped(options, wrapped) {\n    // Build the wrapped content.\n    options._wrap = build(options, true, // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n    jQuery.isArray(wrapped) ? wrapped : [htmlExpr.test(wrapped) ? wrapped : jQuery(wrapped).html()]).join(\"\");\n  }\n\n  function unescape(args) {\n    return args ? args.replace(/\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\") : null;\n  }\n\n  function outerHtml(elem) {\n    var div = document.createElement(\"div\");\n    div.appendChild(elem.cloneNode(true));\n    return div.innerHTML;\n  } // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n\n\n  function storeTmplItems(content) {\n    var keySuffix = \"_\" + cloneIndex,\n        elem,\n        elems,\n        newClonedItems = {},\n        i,\n        l,\n        m;\n\n    for (i = 0, l = content.length; i < l; i++) {\n      if ((elem = content[i]).nodeType !== 1) {\n        continue;\n      }\n\n      elems = elem.getElementsByTagName(\"*\");\n\n      for (m = elems.length - 1; m >= 0; m--) {\n        processItemKey(elems[m]);\n      }\n\n      processItemKey(elem);\n    }\n\n    function processItemKey(el) {\n      var pntKey,\n          pntNode = el,\n          pntItem,\n          tmplItem,\n          key; // Ensure that each rendered template inserted into the DOM has its own template item,\n\n      if (key = el.getAttribute(tmplItmAtt)) {\n        while (pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute(tmplItmAtt))) {}\n\n        if (pntKey !== key) {\n          // The next ancestor with a _tmplitem expando is on a different key than this one.\n          // So this is a top-level element within this template item\n          // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n          pntNode = pntNode.parentNode ? pntNode.nodeType === 11 ? 0 : pntNode.getAttribute(tmplItmAtt) || 0 : 0;\n\n          if (!(tmplItem = newTmplItems[key])) {\n            // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n            tmplItem = wrappedItems[key];\n            tmplItem = newTmplItem(tmplItem, newTmplItems[pntNode] || wrappedItems[pntNode], null, true);\n            tmplItem.key = ++itemKey;\n            newTmplItems[itemKey] = tmplItem;\n          }\n\n          if (cloneIndex) {\n            cloneTmplItem(key);\n          }\n        }\n\n        el.removeAttribute(tmplItmAtt);\n      } else if (cloneIndex && (tmplItem = jQuery.data(el, \"tmplItem\"))) {\n        // This was a rendered element, cloned during append or appendTo etc.\n        // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n        cloneTmplItem(tmplItem.key);\n        newTmplItems[tmplItem.key] = tmplItem;\n        pntNode = jQuery.data(el.parentNode, \"tmplItem\");\n        pntNode = pntNode ? pntNode.key : 0;\n      }\n\n      if (tmplItem) {\n        pntItem = tmplItem; // Find the template item of the parent element.\n        // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n\n        while (pntItem && pntItem.key != pntNode) {\n          // Add this element as a top-level node for this rendered template item, as well as for any\n          // ancestor items between this item and the item of its parent element\n          pntItem.nodes.push(el);\n          pntItem = pntItem.parent;\n        } // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n\n\n        delete tmplItem._ctnt;\n        delete tmplItem._wrap; // Store template item as jQuery data on the element\n\n        jQuery.data(el, \"tmplItem\", tmplItem);\n      }\n\n      function cloneTmplItem(key) {\n        key = key + keySuffix;\n        tmplItem = newClonedItems[key] = newClonedItems[key] || newTmplItem(tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true);\n      }\n    }\n  } //---- Helper functions for template item ----\n\n\n  function tiCalls(content, tmpl, data, options) {\n    if (!content) {\n      return stack.pop();\n    }\n\n    stack.push({\n      _: content,\n      tmpl: tmpl,\n      item: this,\n      data: data,\n      options: options\n    });\n  }\n\n  function tiNest(tmpl, data, options) {\n    // nested template, using {{tmpl}} tag\n    return jQuery.tmpl(jQuery.template(tmpl), data, options, this);\n  }\n\n  function tiWrap(call, wrapped) {\n    // nested template, using {{wrap}} tag\n    var options = call.options || {};\n    options.wrapped = wrapped; // Apply the template, which may incorporate wrapped content,\n\n    return jQuery.tmpl(jQuery.template(call.tmpl), call.data, options, call.item);\n  }\n\n  function tiHtml(filter, textOnly) {\n    var wrapped = this._wrap;\n    return jQuery.map(jQuery(jQuery.isArray(wrapped) ? wrapped.join(\"\") : wrapped).filter(filter || \"*\"), function (e) {\n      return textOnly ? e.innerText || e.textContent : e.outerHTML || outerHtml(e);\n    });\n  }\n\n  function tiUpdate() {\n    var coll = this.nodes;\n    jQuery.tmpl(null, null, null, this).insertBefore(coll[0]);\n    jQuery(coll).remove();\n  }\n})(jQuery);","map":{"version":3,"mappings":"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","names":["jQuery","undefined","oldManip","fn","domManip","tmplItmAtt","htmlExpr","newTmplItems","wrappedItems","appendToTmplItems","topTmplItem","key","data","itemKey","cloneIndex","stack","newTmplItem","options","parentItem","newItem","_wrap","tmpl","parent","nodes","calls","tiCalls","nest","tiNest","wrap","tiWrap","html","tiHtml","update","tiUpdate","extend","_ctnt","length","each","appendTo","prependTo","insertBefore","insertAfter","replaceAll","name","original","selector","ret","insert","elems","i","l","tmplItems","parentNode","nodeType","childNodes","clone","get","apply","concat","pushStack","complete","tmplItem","template","args","table","callback","dmArgs","makeArray","arguments","argsLength","fragClone","afterManip","topLevel","wrapped","updateWrapped","build","call","isArray","map","dataItem","elem","buildTmplFn","innerHTML","test","encode","text","split","join","tag","_default","$2","open","close","$1","items","content","storeTmplItems","nested","frag","item","replace","all","before","middle","after","unencode","el","document","createElement","markup","Function","trim","slash","type","fnargs","target","parens","def","expr","exprAutoFnDetect","unescape","indexOf","params","outerHtml","div","appendChild","cloneNode","keySuffix","newClonedItems","m","getElementsByTagName","processItemKey","pntKey","pntNode","pntItem","getAttribute","cloneTmplItem","removeAttribute","push","pop","_","filter","textOnly","e","innerText","textContent","outerHTML","coll","remove"],"sources":["/home/agustibr/.asdf/installs/ruby/3.0.2/lib/ruby/gems/3.0.0/bundler/gems/decidim-a25b5c74f78d/decidim-core/app/packs/src/decidim/vendor/jquery-tmpl.js"],"sourcesContent":["/* eslint-disable */\n\n/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n;(function( jQuery, undefined ){\n    var oldManip = jQuery.fn.domManip, tmplItmAtt = \"_tmplitem\", htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n        newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];\n\n    function newTmplItem( options, parentItem, fn, data ) {\n        // Returns a template item data structure for a new rendered instance of a template (a 'template item').\n        // The content field is a hierarchical array of strings and nested items (to be\n        // removed and replaced by nodes field of dom elements, once inserted in DOM).\n        var newItem = {\n            data: data || (parentItem ? parentItem.data : {}),\n            _wrap: parentItem ? parentItem._wrap : null,\n            tmpl: null,\n            parent: parentItem || null,\n            nodes: [],\n            calls: tiCalls,\n            nest: tiNest,\n            wrap: tiWrap,\n            html: tiHtml,\n            update: tiUpdate\n        };\n        if ( options ) {\n            jQuery.extend( newItem, options, { nodes: [], parent: parentItem } );\n        }\n        if ( fn ) {\n            // Build the hierarchical content to be used during insertion into DOM\n            newItem.tmpl = fn;\n            newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );\n            newItem.key = ++itemKey;\n            // Keep track of new template item, until it is stored as jQuery Data on DOM element\n            (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n        }\n        return newItem;\n    }\n\n    // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n    jQuery.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n    }, function( name, original ) {\n        jQuery.fn[ name ] = function( selector ) {\n            var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,\n                parent = this.length === 1 && this[0].parentNode;\n\n            appendToTmplItems = newTmplItems || {};\n            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n                insert[ original ]( this[0] );\n                ret = this;\n            } else {\n                for ( i = 0, l = insert.length; i < l; i++ ) {\n                    cloneIndex = i;\n                    elems = (i > 0 ? this.clone(true) : this).get();\n                    jQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n                    ret = ret.concat( elems );\n                }\n                cloneIndex = 0;\n                ret = this.pushStack( ret, name, insert.selector );\n            }\n            tmplItems = appendToTmplItems;\n            appendToTmplItems = null;\n            jQuery.tmpl.complete( tmplItems );\n            return ret;\n        };\n    });\n\n    jQuery.fn.extend({\n        // Use first wrapped element as template markup.\n        // Return wrapped set of template items, obtained by rendering template against data.\n        tmpl: function( data, options, parentItem ) {\n            return jQuery.tmpl( this[0], data, options, parentItem );\n        },\n\n        // Find which rendered template item the first wrapped DOM element belongs to\n        tmplItem: function() {\n            return jQuery.tmplItem( this[0] );\n        },\n\n        // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n        template: function( name ) {\n            return jQuery.template( name, this[0] );\n        },\n\n        domManip: function( args, table, callback, options ) {\n            // This appears to be a bug in the appendTo, etc. implementation\n            // it should be doing .call() instead of .apply(). See #6227\n            if ( args[0] && args[0].nodeType ) {\n                var dmArgs = jQuery.makeArray( arguments ), argsLength = args.length, i = 0, tmplItem;\n                while ( i < argsLength && !(tmplItem = jQuery.data( args[i++], \"tmplItem\" ))) {}\n                if ( argsLength > 1 ) {\n                    dmArgs[0] = [jQuery.makeArray( args )];\n                }\n                if ( tmplItem && cloneIndex ) {\n                    dmArgs[2] = function( fragClone ) {\n                        // Handler called by oldManip when rendered template has been inserted into DOM.\n                        jQuery.tmpl.afterManip( this, fragClone, callback );\n                    };\n                }\n                oldManip.apply( this, dmArgs );\n            } else {\n                oldManip.apply( this, arguments );\n            }\n            cloneIndex = 0;\n            if ( !appendToTmplItems ) {\n                jQuery.tmpl.complete( newTmplItems );\n            }\n            return this;\n        }\n    });\n\n    jQuery.extend({\n        // Return wrapped set of template items, obtained by rendering template against data.\n        tmpl: function( tmpl, data, options, parentItem ) {\n            var ret, topLevel = !parentItem;\n            if ( topLevel ) {\n                // This is a top-level tmpl call (not from a nested template using {{tmpl}})\n                parentItem = topTmplItem;\n                tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );\n                wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n            } else if ( !tmpl ) {\n                // The template item is already associated with DOM - this is a refresh.\n                // Re-evaluate rendered template for the parentItem\n                tmpl = parentItem.tmpl;\n                newTmplItems[parentItem.key] = parentItem;\n                parentItem.nodes = [];\n                if ( parentItem.wrapped ) {\n                    updateWrapped( parentItem, parentItem.wrapped );\n                }\n                // Rebuild, without creating a new template item\n                return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));\n            }\n            if ( !tmpl ) {\n                return []; // Could throw...\n            }\n            if ( typeof data === \"function\" ) {\n                data = data.call( parentItem || {} );\n            }\n            if ( options && options.wrapped ) {\n                updateWrapped( options, options.wrapped );\n            }\n            ret = jQuery.isArray( data ) ?\n                jQuery.map( data, function( dataItem ) {\n                    return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;\n                }) :\n                [ newTmplItem( options, parentItem, tmpl, data ) ];\n            return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;\n        },\n\n        // Return rendered template item for an element.\n        tmplItem: function( elem ) {\n            var tmplItem;\n            if ( elem instanceof jQuery ) {\n                elem = elem[0];\n            }\n            while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, \"tmplItem\" )) && (elem = elem.parentNode) ) {}\n            return tmplItem || topTmplItem;\n        },\n\n        // Set:\n        // Use $.template( name, tmpl ) to cache a named template,\n        // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n        // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n\n        // Get:\n        // Use $.template( name ) to access a cached template.\n        // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n        // will return the compiled template, without adding a name reference.\n        // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n        // to $.template( null, templateString )\n        template: function( name, tmpl ) {\n            if (tmpl) {\n                // Compile template and associate with name\n                if ( typeof tmpl === \"string\" ) {\n                    // This is an HTML string being passed directly in.\n                    tmpl = buildTmplFn( tmpl )\n                } else if ( tmpl instanceof jQuery ) {\n                    tmpl = tmpl[0] || {};\n                }\n                if ( tmpl.nodeType ) {\n                    // If this is a template block, use cached copy, or generate tmpl function and cache.\n                    tmpl = jQuery.data( tmpl, \"tmpl\" ) || jQuery.data( tmpl, \"tmpl\", buildTmplFn( tmpl.innerHTML ));\n                }\n                return typeof name === \"string\" ? (jQuery.template[name] = tmpl) : tmpl;\n            }\n            // Return named compiled template\n            return name ? (typeof name !== \"string\" ? jQuery.template( null, name ):\n                (jQuery.template[name] ||\n                    // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\n                    jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;\n        },\n\n        encode: function( text ) {\n            // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n            return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n        }\n    });\n\n    jQuery.extend( jQuery.tmpl, {\n        tag: {\n            \"tmpl\": {\n                _default: { $2: \"null\" },\n                open: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\"\n                // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n                // This means that {{tmpl foo}} treats foo as a template (which IS a function).\n                // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n            },\n            \"wrap\": {\n                _default: { $2: \"null\" },\n                open: \"$item.calls(_,$1,$2);_=[];\",\n                close: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n            },\n            \"each\": {\n                _default: { $2: \"$index, $value\" },\n                open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n                close: \"}});}\"\n            },\n            \"if\": {\n                open: \"if(($notnull_1) && $1a){\",\n                close: \"}\"\n            },\n            \"else\": {\n                _default: { $1: \"true\" },\n                open: \"}else if(($notnull_1) && $1a){\"\n            },\n            \"html\": {\n                // Unecoded expression evaluation.\n                open: \"if($notnull_1){_.push($1a);}\"\n            },\n            \"=\": {\n                // Encoded expression evaluation. Abbreviated form is ${}.\n                _default: { $1: \"$data\" },\n                open: \"if($notnull_1){_.push($.encode($1a));}\"\n            },\n            \"!\": {\n                // Comment tag. Skipped by parser\n                open: \"\"\n            }\n        },\n\n        // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n        complete: function( items ) {\n            newTmplItems = {};\n        },\n\n        // Call this from code which overrides domManip, or equivalent\n        // Manage cloning/storing template items etc.\n        afterManip: function afterManip( elem, fragClone, callback ) {\n            // Provides cloned fragment ready for fixup prior to and after insertion into DOM\n            var content = fragClone.nodeType === 11 ?\n                jQuery.makeArray(fragClone.childNodes) :\n                fragClone.nodeType === 1 ? [fragClone] : [];\n\n            // Return fragment to original caller (e.g. append) for DOM insertion\n            callback.call( elem, fragClone );\n\n            // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n            storeTmplItems( content );\n            cloneIndex++;\n        }\n    });\n\n    //========================== Private helper functions, used by code above ==========================\n\n    function build( tmplItem, nested, content ) {\n        // Convert hierarchical content into flat string array\n        // and finally return array of fragments ready for DOM insertion\n        var frag, ret = content ? jQuery.map( content, function( item ) {\n            return (typeof item === \"string\") ?\n                // Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n                (tmplItem.key ? item.replace( /(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\" ) : item) :\n                // This is a child template item. Build nested template.\n                build( item, tmplItem, item._ctnt );\n        }) :\n        // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n        tmplItem;\n        if ( nested ) {\n            return ret;\n        }\n\n        // top-level template\n        ret = ret.join(\"\");\n\n        // Support templates which have initial or final text nodes, or consist only of text\n        // Also support HTML entities within the HTML markup.\n        ret.replace( /^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function( all, before, middle, after) {\n            frag = jQuery( middle ).get();\n\n            storeTmplItems( frag );\n            if ( before ) {\n                frag = unencode( before ).concat(frag);\n            }\n            if ( after ) {\n                frag = frag.concat(unencode( after ));\n            }\n        });\n        return frag ? frag : unencode( ret );\n    }\n\n    function unencode( text ) {\n        // Use createElement, since createTextNode will not render HTML entities correctly\n        var el = document.createElement( \"div\" );\n        el.innerHTML = text;\n        return jQuery.makeArray(el.childNodes);\n    }\n\n    // Generate a reusable function that will serve to render a template against data\n    function buildTmplFn( markup ) {\n        return new Function(\"jQuery\",\"$item\",\n            \"var $=jQuery,call,_=[],$data=$item.data;\" +\n\n            // Introduce the data as local variables using with(){}\n            \"with($data){_.push('\" +\n\n            // Convert the template into pure JavaScript\n            jQuery.trim(markup)\n                .replace( /([\\\\'])/g, \"\\\\$1\" )\n                .replace( /[\\r\\t\\n]/g, \" \" )\n                .replace( /\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\" )\n                .replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n                function( all, slash, type, fnargs, target, parens, args ) {\n                    var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;\n                    if ( !tag ) {\n                        throw \"Template command not found: \" + type;\n                    }\n                    def = tag._default || [];\n                    if ( parens && !/\\w$/.test(target)) {\n                        target += parens;\n                        parens = \"\";\n                    }\n                    if ( target ) {\n                        target = unescape( target );\n                        args = args ? (\",\" + unescape( args ) + \")\") : (parens ? \")\" : \"\");\n                        // Support for target being things like a.toLowerCase();\n                        // In that case don't call with template item as 'this' pointer. Just evaluate...\n                        expr = parens ? (target.indexOf(\".\") > -1 ? target + parens : (\"(\" + target + \").call($item\" + args)) : target;\n                        exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n                    } else {\n                        exprAutoFnDetect = expr = def.$1 || \"null\";\n                    }\n                    fnargs = unescape( fnargs );\n                    return \"');\" +\n                        tag[ slash ? \"close\" : \"open\" ]\n                            .split( \"$notnull_1\" ).join( target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\" )\n                            .split( \"$1a\" ).join( exprAutoFnDetect )\n                            .split( \"$1\" ).join( expr )\n                            .split( \"$2\" ).join( fnargs ?\n                                fnargs.replace( /\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function( all, name, parens, params ) {\n                                    params = params ? (\",\" + params + \")\") : (parens ? \")\" : \"\");\n                                    return params ? (\"(\" + name + \").call($item\" + params) : all;\n                                })\n                                : (def.$2||\"\")\n                            ) +\n                        \"_.push('\";\n                }) +\n            \"');}return _;\"\n        );\n    }\n    function updateWrapped( options, wrapped ) {\n        // Build the wrapped content.\n        options._wrap = build( options, true,\n            // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n            jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]\n        ).join(\"\");\n    }\n\n    function unescape( args ) {\n        return args ? args.replace( /\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\" ) : null;\n    }\n    function outerHtml( elem ) {\n        var div = document.createElement(\"div\");\n        div.appendChild( elem.cloneNode(true) );\n        return div.innerHTML;\n    }\n\n    // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n    function storeTmplItems( content ) {\n        var keySuffix = \"_\" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;\n        for ( i = 0, l = content.length; i < l; i++ ) {\n            if ( (elem = content[i]).nodeType !== 1 ) {\n                continue;\n            }\n            elems = elem.getElementsByTagName(\"*\");\n            for ( m = elems.length - 1; m >= 0; m-- ) {\n                processItemKey( elems[m] );\n            }\n            processItemKey( elem );\n        }\n        function processItemKey( el ) {\n            var pntKey, pntNode = el, pntItem, tmplItem, key;\n            // Ensure that each rendered template inserted into the DOM has its own template item,\n            if ( (key = el.getAttribute( tmplItmAtt ))) {\n                while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }\n                if ( pntKey !== key ) {\n                    // The next ancestor with a _tmplitem expando is on a different key than this one.\n                    // So this is a top-level element within this template item\n                    // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n                    pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;\n                    if ( !(tmplItem = newTmplItems[key]) ) {\n                        // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n                        tmplItem = wrappedItems[key];\n                        tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode], null, true );\n                        tmplItem.key = ++itemKey;\n                        newTmplItems[itemKey] = tmplItem;\n                    }\n                    if ( cloneIndex ) {\n                        cloneTmplItem( key );\n                    }\n                }\n                el.removeAttribute( tmplItmAtt );\n            } else if ( cloneIndex && (tmplItem = jQuery.data( el, \"tmplItem\" )) ) {\n                // This was a rendered element, cloned during append or appendTo etc.\n                // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n                cloneTmplItem( tmplItem.key );\n                newTmplItems[tmplItem.key] = tmplItem;\n                pntNode = jQuery.data( el.parentNode, \"tmplItem\" );\n                pntNode = pntNode ? pntNode.key : 0;\n            }\n            if ( tmplItem ) {\n                pntItem = tmplItem;\n                // Find the template item of the parent element.\n                // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n                while ( pntItem && pntItem.key != pntNode ) {\n                    // Add this element as a top-level node for this rendered template item, as well as for any\n                    // ancestor items between this item and the item of its parent element\n                    pntItem.nodes.push( el );\n                    pntItem = pntItem.parent;\n                }\n                // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n                delete tmplItem._ctnt;\n                delete tmplItem._wrap;\n                // Store template item as jQuery data on the element\n                jQuery.data( el, \"tmplItem\", tmplItem );\n            }\n            function cloneTmplItem( key ) {\n                key = key + keySuffix;\n                tmplItem = newClonedItems[key] =\n                    (newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true ));\n            }\n        }\n    }\n\n    //---- Helper functions for template item ----\n\n    function tiCalls( content, tmpl, data, options ) {\n        if ( !content ) {\n            return stack.pop();\n        }\n        stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });\n    }\n\n    function tiNest( tmpl, data, options ) {\n        // nested template, using {{tmpl}} tag\n        return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );\n    }\n\n    function tiWrap( call, wrapped ) {\n        // nested template, using {{wrap}} tag\n        var options = call.options || {};\n        options.wrapped = wrapped;\n        // Apply the template, which may incorporate wrapped content,\n        return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );\n    }\n\n    function tiHtml( filter, textOnly ) {\n        var wrapped = this._wrap;\n        return jQuery.map(\n            jQuery( jQuery.isArray( wrapped ) ? wrapped.join(\"\") : wrapped ).filter( filter || \"*\" ),\n            function(e) {\n                return textOnly ?\n                    e.innerText || e.textContent :\n                    e.outerHTML || outerHtml(e);\n            });\n    }\n\n    function tiUpdate() {\n        var coll = this.nodes;\n        jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );\n        jQuery( coll ).remove();\n    }\n})( jQuery );\n"]},"metadata":{},"sourceType":"module"}