{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar COUNT_KEY = \"%count%\"; // How often SR announces the message in relation to maximum characters. E.g.\n// if max characters is 1000, screen reader announces the remaining characters\n// every 100 (= 0.1 * 1000) characters. This will be \"floored\" to the closest\n// 100 if the maximum characters > 100. E.g. if max characters is 5500, the\n// threshold is 500 (= Math.floor(550 / 100) * 100). With 100 or less\n// characters, this ratio is omitted and the announce threshold is always set to\n// 10.\n\nvar SR_ANNOUNCE_THRESHOLD_RATIO = 0.1; // The number of characters left after which every keystroke will be announced.\n\nvar SR_ANNOUNCE_EVERY_THRESHOLD = 10;\nvar DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: \"at least \".concat(COUNT_KEY, \" character\"),\n    other: \"at least \".concat(COUNT_KEY, \" characters\")\n  },\n  charactersLeft: {\n    one: \"\".concat(COUNT_KEY, \" character left\"),\n    other: \"\".concat(COUNT_KEY, \" characters left\")\n  }\n};\nvar MESSAGES = DEFAULT_MESSAGES;\n\nvar InputCharacterCounter = /*#__PURE__*/function () {\n  function InputCharacterCounter(input) {\n    _classCallCheck(this, InputCharacterCounter);\n\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n    this.describeByCounter = typeof this.$input.attr(\"aria-describedby\") === \"undefined\"; // Define the closest length for the input \"gaps\" defined by the threshold.\n\n    if (this.maxCharacters > 10) {\n      if (this.maxCharacters > 100) {\n        this.announceThreshold = Math.floor(this.maxCharacters * SR_ANNOUNCE_THRESHOLD_RATIO / 100) * 100;\n      } else {\n        this.announceThreshold = 10;\n      } // The number of characters left after which every keystroke will be announced.\n\n\n      this.announceEveryThreshold = SR_ANNOUNCE_EVERY_THRESHOLD;\n    } else {\n      this.announceThreshold = 1;\n      this.announceEveryThreshold = 1;\n    }\n\n    var targetId = this.$target.attr(\"id\");\n\n    if (typeof targetId === \"undefined\") {\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = \"\".concat(this.$input.attr(\"id\"), \"_characters\");\n      } else {\n        targetId = \"characters_\".concat(Math.random().toString(36).substr(2, 9));\n      }\n    }\n\n    if (this.$target.length > 0) {\n      this.$target.attr(\"id\", targetId);\n    } else {\n      this.$target = $(\"<span id=\\\"\".concat(targetId, \"\\\" class=\\\"form-input-extra-before\\\" />\")); // If input is a hidden for WYSIWYG editor add it at the end\n\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      } // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (this.$input.parent().is(\".columns\") && this.$input.parent().parent().is(\".row\")) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    this.updateInputLength();\n    this.previousInputLength = this.inputLength;\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      // Create the screen reader target element. We don't want to constantly\n      // announce every change to screen reader, only occasionally.\n      this.$srTarget = $(\"<span role=\\\"status\\\" id=\\\"\".concat(targetId, \"_sr\\\" class=\\\"show-for-sr remaining-character-count-sr\\\" />\"));\n      this.$target.before(this.$srTarget);\n      this.$target.attr(\"aria-hidden\", \"true\");\n      this.setDescribedBy(true);\n      this.bindEvents();\n    }\n  }\n\n  _createClass(InputCharacterCounter, [{\n    key: \"setDescribedBy\",\n    value: function setDescribedBy(active) {\n      if (!this.describeByCounter) {\n        return;\n      }\n\n      if (active) {\n        this.$input.attr(\"aria-describedby\", this.$srTarget.attr(\"id\"));\n      } else {\n        this.$input.removeAttr(\"aria-describedby\");\n      }\n    }\n  }, {\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this = this; // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n\n\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(function () {\n          var editor = Quill.find(_this.$input.siblings(\".editor-container\")[0]);\n          editor.on(\"text-change\", function () {\n            _this.updateStatus();\n          });\n        });\n      }\n\n      this.$input.on(\"keyup\", function () {\n        _this.updateStatus();\n      });\n      this.$input.on(\"input\", function () {\n        _this.updateInputLength();\n\n        _this.checkScreenReaderUpdate(); // If the input is \"described by\" the character counter, some screen\n        // readers (NVDA) announce the status twice when it is updated. By\n        // removing the aria-describedby attribute while the user is typing makes\n        // the screen reader announce the status only once.\n\n\n        _this.setDescribedBy(false);\n      });\n      this.$input.on(\"focus\", function () {\n        _this.updateScreenReaderStatus();\n      });\n      this.$input.on(\"blur\", function () {\n        _this.updateScreenReaderStatus();\n\n        _this.setDescribedBy(true);\n      });\n\n      if (this.$input.get(0) !== null) {\n        this.$input.get(0).addEventListener(\"emoji.added\", function () {\n          _this.updateStatus();\n        });\n      }\n\n      this.updateStatus();\n      this.updateScreenReaderStatus();\n    }\n  }, {\n    key: \"getInputLength\",\n    value: function getInputLength() {\n      return this.inputLength;\n    }\n  }, {\n    key: \"updateInputLength\",\n    value: function updateInputLength() {\n      this.previousInputLength = this.inputLength;\n      this.inputLength = this.$input.val().length;\n    }\n    /**\n     * This compares the current inputLength to the previous value and decides\n     * whether the user is currently adding or deleting characters from the view.\n     *\n     * @returns {String} The input direction either \"ins\" for insert or \"del\" for\n     *   delete.\n     */\n\n  }, {\n    key: \"getInputDirection\",\n    value: function getInputDirection() {\n      if (this.inputLength < this.previousInputLength) {\n        return \"del\";\n      }\n\n      return \"ins\";\n    }\n  }, {\n    key: \"getScreenReaderLength\",\n    value: function getScreenReaderLength() {\n      var currentLength = this.getInputLength();\n\n      if (this.maxCharacters < 10) {\n        return currentLength;\n      } else if (this.maxCharacters - currentLength <= this.announceEveryThreshold) {\n        return currentLength;\n      }\n\n      var srLength = currentLength - currentLength % this.announceThreshold; // Prevent the screen reader telling too many characters left if the user\n      // deletes a characters. This can cause confusing experience e.g. when the\n      // user is closing the maximum amount of characters, so if the previous\n      // announcement was \"10 characters left\" and the user removes one character,\n      // the screen reader would announce \"100 characters left\" next time (when\n      // they actually have only 11 characters left). Similar when they are\n      // deleting a character at 900 characters, the screen reader would announce\n      // \"1000 characters left\" even when they only have 901 characters left.\n\n      if (this.getInputDirection() === \"del\") {\n        // The first branch makes sure that if the SR length matches the actual\n        // length, it will be always announced.\n        if (srLength === currentLength) {\n          return srLength; // The second branch checks that if we are at the final threshold, we\n          // should not announce \"0 characters left\" when the user deletes more than\n          // the \"announce after every stroke\" limit (this.announceEveryThreshold).\n        } else if (this.maxCharacters - srLength === this.announceThreshold) {\n          return this.announcedAt || currentLength; // The third branch checks that when deleting characters, we should\n          // announce the next threshold to get accurate annoucement. E.g. when we\n          // have 750 characters left and the user deletes 100 characters at once,\n          // we should announce \"700 characters left\" after that deletion.\n        } else if (srLength < currentLength) {\n          return srLength + this.announceThreshold;\n        } // This fixes an issue in the following situation:\n        // 1. 750 characters left\n        // 2. Delete 100 characters in a row\n        // 3. SR: \"800 characters left\" (actual 850)\n        // 4. Type one additional character\n        // 5. Without this, SR would announce \"900 characters left\" = confusing\n\n      } else if (srLength < this.announcedAt) {\n        return this.announcedAt;\n      }\n\n      return srLength;\n    }\n  }, {\n    key: \"getMessages\",\n    value: function getMessages() {\n      var currentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var showMessages = [];\n      var inputLength = currentLength;\n\n      if (inputLength === null) {\n        inputLength = this.getInputLength();\n      }\n\n      if (this.minCharacters > 0) {\n        var message = MESSAGES.charactersAtLeast.other;\n\n        if (this.minCharacters === 1) {\n          message = MESSAGES.charactersAtLeast.one;\n        }\n\n        showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n      }\n\n      if (this.maxCharacters > 0) {\n        var remaining = this.maxCharacters - inputLength;\n        var _message = MESSAGES.charactersLeft.other;\n\n        if (remaining === 1) {\n          _message = MESSAGES.charactersLeft.one;\n        }\n\n        this.$input[0].dispatchEvent(new CustomEvent(\"characterCounter\", {\n          detail: {\n            remaining: remaining\n          }\n        }));\n        showMessages.push(_message.replace(COUNT_KEY, remaining));\n      }\n\n      return showMessages;\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus() {\n      this.$target.text(this.getMessages().join(\", \"));\n    }\n  }, {\n    key: \"checkScreenReaderUpdate\",\n    value: function checkScreenReaderUpdate() {\n      if (this.maxCharacters < 1) {\n        return;\n      }\n\n      var currentLength = this.getScreenReaderLength();\n\n      if (currentLength === this.announcedAt) {\n        return;\n      }\n\n      this.announcedAt = currentLength;\n      this.updateScreenReaderStatus(currentLength);\n    }\n  }, {\n    key: \"updateScreenReaderStatus\",\n    value: function updateScreenReaderStatus() {\n      var currentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.$srTarget.text(this.getMessages(currentLength).join(\", \"));\n    }\n  }], [{\n    key: \"configureMessages\",\n    value: function configureMessages(messages) {\n      MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n    }\n  }]);\n\n  return InputCharacterCounter;\n}();\n\nexport { InputCharacterCounter as default };\n\nvar createCharacterCounter = function createCharacterCounter($input) {\n  $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n};\n\n$(function () {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each(function (_i, elem) {\n    var $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\nexport { InputCharacterCounter, createCharacterCounter };","map":{"version":3,"mappings":"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","names":["COUNT_KEY","SR_ANNOUNCE_THRESHOLD_RATIO","SR_ANNOUNCE_EVERY_THRESHOLD","DEFAULT_MESSAGES","charactersAtLeast","one","other","charactersLeft","MESSAGES","InputCharacterCounter","input","_classCallCheck","$input","$target","$","data","minCharacters","parseInt","attr","maxCharacters","describeByCounter","announceThreshold","Math","floor","announceEveryThreshold","targetId","length","random","toString","substr","parent","is","after","updateInputLength","previousInputLength","inputLength","$srTarget","before","setDescribedBy","bindEvents","active","removeAttr","Quill","setTimeout","editor","find","_this","siblings","on","updateStatus","checkScreenReaderUpdate","updateScreenReaderStatus","get","addEventListener","val","currentLength","getInputLength","srLength","getInputDirection","announcedAt","showMessages","message","push","replace","remaining","dispatchEvent","CustomEvent","detail","text","getMessages","join","getScreenReaderLength","messages","extend","createCharacterCounter","each","_i","elem"],"sources":["/home/agustibr/.asdf/installs/ruby/3.0.2/lib/ruby/gems/3.0.0/bundler/gems/decidim-a25b5c74f78d/decidim-core/app/packs/src/decidim/input_character_counter.js"],"sourcesContent":["const COUNT_KEY = \"%count%\";\n// How often SR announces the message in relation to maximum characters. E.g.\n// if max characters is 1000, screen reader announces the remaining characters\n// every 100 (= 0.1 * 1000) characters. This will be \"floored\" to the closest\n// 100 if the maximum characters > 100. E.g. if max characters is 5500, the\n// threshold is 500 (= Math.floor(550 / 100) * 100). With 100 or less\n// characters, this ratio is omitted and the announce threshold is always set to\n// 10.\nconst SR_ANNOUNCE_THRESHOLD_RATIO = 0.1;\n// The number of characters left after which every keystroke will be announced.\nconst SR_ANNOUNCE_EVERY_THRESHOLD = 10;\nconst DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: `at least ${COUNT_KEY} character`,\n    other: `at least ${COUNT_KEY} characters`\n  },\n  charactersLeft: {\n    one: `${COUNT_KEY} character left`,\n    other: `${COUNT_KEY} characters left`\n  }\n};\nlet MESSAGES = DEFAULT_MESSAGES;\n\nexport default class InputCharacterCounter {\n  static configureMessages(messages) {\n    MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n  }\n\n  constructor(input) {\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n    this.describeByCounter = typeof this.$input.attr(\"aria-describedby\") === \"undefined\";\n\n    // Define the closest length for the input \"gaps\" defined by the threshold.\n    if (this.maxCharacters > 10) {\n      if (this.maxCharacters > 100) {\n        this.announceThreshold = Math.floor(this.maxCharacters * SR_ANNOUNCE_THRESHOLD_RATIO / 100) * 100;\n      } else {\n        this.announceThreshold = 10;\n      }\n\n      // The number of characters left after which every keystroke will be announced.\n      this.announceEveryThreshold = SR_ANNOUNCE_EVERY_THRESHOLD;\n    } else {\n      this.announceThreshold = 1;\n      this.announceEveryThreshold = 1;\n    }\n\n    let targetId = this.$target.attr(\"id\");\n    if (typeof targetId === \"undefined\") {\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = `${this.$input.attr(\"id\")}_characters`;\n      } else {\n        targetId = `characters_${Math.random().toString(36).substr(2, 9)}`;\n      }\n    }\n\n    if (this.$target.length > 0) {\n      this.$target.attr(\"id\", targetId)\n    } else {\n      this.$target = $(`<span id=\"${targetId}\" class=\"form-input-extra-before\" />`)\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (\n        this.$input.parent().is(\".columns\") &&\n        this.$input.parent().parent().is(\".row\")\n      ) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    this.updateInputLength();\n    this.previousInputLength = this.inputLength;\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      // Create the screen reader target element. We don't want to constantly\n      // announce every change to screen reader, only occasionally.\n      this.$srTarget = $(\n        `<span role=\"status\" id=\"${targetId}_sr\" class=\"show-for-sr remaining-character-count-sr\" />`\n      );\n      this.$target.before(this.$srTarget);\n      this.$target.attr(\"aria-hidden\", \"true\");\n      this.setDescribedBy(true);\n\n      this.bindEvents();\n    }\n  }\n\n  setDescribedBy(active) {\n    if (!this.describeByCounter) {\n      return;\n    }\n\n    if (active) {\n      this.$input.attr(\"aria-describedby\", this.$srTarget.attr(\"id\"));\n    } else {\n      this.$input.removeAttr(\"aria-describedby\");\n    }\n  }\n\n  bindEvents() {\n    // In WYSIWYG editors (Quill) we need to find the active editor from the\n    // DOM node. Quill has the experimental \"find\" method that should work\n    // fine in this case\n    if (Quill && this.$input.parent().is(\".editor\")) {\n      // Wait until the next javascript loop so Quill editors are created\n      setTimeout(() => {\n        const editor = Quill.find(this.$input.siblings(\".editor-container\")[0]);\n        editor.on(\"text-change\", () => {\n          this.updateStatus();\n        });\n      })\n    }\n    this.$input.on(\"keyup\", () => {\n      this.updateStatus();\n    });\n    this.$input.on(\"input\", () => {\n      this.updateInputLength();\n      this.checkScreenReaderUpdate();\n      // If the input is \"described by\" the character counter, some screen\n      // readers (NVDA) announce the status twice when it is updated. By\n      // removing the aria-describedby attribute while the user is typing makes\n      // the screen reader announce the status only once.\n      this.setDescribedBy(false);\n    });\n    this.$input.on(\"focus\", () => {\n      this.updateScreenReaderStatus();\n    });\n    this.$input.on(\"blur\", () => {\n      this.updateScreenReaderStatus();\n      this.setDescribedBy(true);\n    });\n    if (this.$input.get(0) !== null) {\n      this.$input.get(0).addEventListener(\"emoji.added\", () => {\n        this.updateStatus();\n      });\n    }\n    this.updateStatus();\n    this.updateScreenReaderStatus();\n  }\n\n  getInputLength() {\n    return this.inputLength;\n  }\n\n  updateInputLength() {\n    this.previousInputLength = this.inputLength;\n    this.inputLength = this.$input.val().length;\n  }\n\n  /**\n   * This compares the current inputLength to the previous value and decides\n   * whether the user is currently adding or deleting characters from the view.\n   *\n   * @returns {String} The input direction either \"ins\" for insert or \"del\" for\n   *   delete.\n   */\n  getInputDirection() {\n    if (this.inputLength < this.previousInputLength) {\n      return \"del\";\n    }\n\n    return \"ins\";\n  }\n\n  getScreenReaderLength() {\n    const currentLength = this.getInputLength();\n    if (this.maxCharacters < 10) {\n      return currentLength;\n    } else if (this.maxCharacters - currentLength <= this.announceEveryThreshold) {\n      return currentLength;\n    }\n\n    const srLength = currentLength - currentLength % this.announceThreshold;\n\n    // Prevent the screen reader telling too many characters left if the user\n    // deletes a characters. This can cause confusing experience e.g. when the\n    // user is closing the maximum amount of characters, so if the previous\n    // announcement was \"10 characters left\" and the user removes one character,\n    // the screen reader would announce \"100 characters left\" next time (when\n    // they actually have only 11 characters left). Similar when they are\n    // deleting a character at 900 characters, the screen reader would announce\n    // \"1000 characters left\" even when they only have 901 characters left.\n    if (this.getInputDirection() === \"del\") {\n      // The first branch makes sure that if the SR length matches the actual\n      // length, it will be always announced.\n      if (srLength === currentLength) {\n        return srLength;\n      // The second branch checks that if we are at the final threshold, we\n      // should not announce \"0 characters left\" when the user deletes more than\n      // the \"announce after every stroke\" limit (this.announceEveryThreshold).\n      } else if (this.maxCharacters - srLength === this.announceThreshold) {\n        return this.announcedAt || currentLength;\n      // The third branch checks that when deleting characters, we should\n      // announce the next threshold to get accurate annoucement. E.g. when we\n      // have 750 characters left and the user deletes 100 characters at once,\n      // we should announce \"700 characters left\" after that deletion.\n      } else if (srLength < currentLength) {\n        return srLength + this.announceThreshold;\n      }\n    // This fixes an issue in the following situation:\n    // 1. 750 characters left\n    // 2. Delete 100 characters in a row\n    // 3. SR: \"800 characters left\" (actual 850)\n    // 4. Type one additional character\n    // 5. Without this, SR would announce \"900 characters left\" = confusing\n    } else if (srLength < this.announcedAt) {\n      return this.announcedAt;\n    }\n\n    return srLength;\n  }\n\n  getMessages(currentLength = null) {\n    const showMessages = [];\n    let inputLength = currentLength;\n    if (inputLength === null) {\n      inputLength = this.getInputLength()\n    }\n\n    if (this.minCharacters > 0) {\n      let message = MESSAGES.charactersAtLeast.other;\n      if (this.minCharacters === 1) {\n        message = MESSAGES.charactersAtLeast.one;\n      }\n      showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n    }\n\n    if (this.maxCharacters > 0) {\n      const remaining = this.maxCharacters - inputLength;\n      let message = MESSAGES.charactersLeft.other;\n      if (remaining === 1) {\n        message = MESSAGES.charactersLeft.one;\n      }\n      this.$input[0].dispatchEvent(\n        new CustomEvent(\"characterCounter\", {detail: {remaining: remaining}})\n      );\n      showMessages.push(message.replace(COUNT_KEY, remaining));\n    }\n\n    return showMessages;\n  }\n\n  updateStatus() {\n    this.$target.text(this.getMessages().join(\", \"));\n  }\n\n  checkScreenReaderUpdate() {\n    if (this.maxCharacters < 1) {\n      return;\n    }\n\n    const currentLength = this.getScreenReaderLength();\n    if (currentLength === this.announcedAt) {\n      return;\n    }\n\n    this.announcedAt = currentLength;\n    this.updateScreenReaderStatus(currentLength);\n  }\n\n  updateScreenReaderStatus(currentLength = null) {\n    this.$srTarget.text(this.getMessages(currentLength).join(\", \"));\n  }\n}\n\nconst createCharacterCounter = ($input) => {\n  $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n}\n\n$(() => {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each((_i, elem) => {\n    const $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\n\nexport {InputCharacterCounter, createCharacterCounter};\n"]},"metadata":{},"sourceType":"module"}