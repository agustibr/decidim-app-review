{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nimport { Keyboard } from \"foundation-sites\";\nvar focusGuardClass = \"focusguard\";\nvar focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nvar focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\n\nvar FocusGuard = /*#__PURE__*/function () {\n  function FocusGuard(container) {\n    _classCallCheck(this, FocusGuard);\n\n    this.container = container;\n    this.guardedElement = null;\n  }\n\n  _createClass(FocusGuard, [{\n    key: \"trap\",\n    value: function trap(element) {\n      if (this.guardedElement) {\n        Keyboard.releaseFocus($(this.guardedElement));\n      }\n\n      this.enable();\n      this.guardedElement = element; // Call the release focus first so that we don't accidentally add the\n      // keyboard trap twice. Note that the Foundation methods expect the elements\n      // to be jQuery elements which is why we pass them through jQuery.\n\n      Keyboard.releaseFocus($(element));\n      Keyboard.trapFocus($(element));\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var _this = this; // Check if the guards already exists due to some other dialog\n\n\n      var guards = this.container.querySelectorAll(\":scope > .\".concat(focusGuardClass));\n\n      if (guards.length > 0) {\n        // Make sure the guards are the first and last element as there have\n        // been changes in the DOM.\n        guards.forEach(function (guard) {\n          if (guard.dataset.position === \"start\") {\n            _this.container.prepend(guard);\n          } else {\n            _this.container.append(guard);\n          }\n        });\n        return;\n      } // Add guards at the start and end of the document and attach their focus\n      // listeners\n\n\n      var startGuard = this.createFocusGuard(\"start\");\n      var endGuard = this.createFocusGuard(\"end\");\n      this.container.prepend(startGuard);\n      this.container.append(endGuard);\n      startGuard.addEventListener(\"focus\", function () {\n        return _this.handleContainerFocus(startGuard);\n      });\n      endGuard.addEventListener(\"focus\", function () {\n        return _this.handleContainerFocus(endGuard);\n      });\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var guards = this.container.querySelectorAll(\":scope > .\".concat(focusGuardClass));\n      guards.forEach(function (guard) {\n        return guard.remove();\n      });\n\n      if (this.guardedElement) {\n        // Note that the Foundation methods expect the elements to be jQuery\n        // elements which is why we pass them through jQuery.\n        Keyboard.releaseFocus($(this.guardedElement));\n        this.guardedElement = null;\n      }\n    }\n  }, {\n    key: \"createFocusGuard\",\n    value: function createFocusGuard(position) {\n      var guard = document.createElement(\"div\");\n      guard.className = focusGuardClass;\n      guard.dataset.position = position;\n      guard.tabIndex = 0;\n      guard.setAttribute(\"aria-hidden\", \"true\");\n      return guard;\n    }\n  }, {\n    key: \"handleContainerFocus\",\n    value: function handleContainerFocus(guard) {\n      var _this2 = this;\n\n      if (!this.guardedElement) {\n        guard.blur();\n        return;\n      }\n\n      var visibleNodes = Array.from(this.guardedElement.querySelectorAll(\"*\")).filter(function (item) {\n        return _this2.isVisible(item);\n      });\n      var target = null;\n\n      if (guard.dataset.position === \"start\") {\n        // Focus at the start guard, so focus the first focusable element after that\n        for (var ind = 0; ind < visibleNodes.length; ind += 1) {\n          if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n            target = visibleNodes[ind];\n            break;\n          }\n        }\n      } else {\n        // Focus at the end guard, so focus the first focusable element after that\n        for (var _ind = visibleNodes.length - 1; _ind >= 0; _ind -= 1) {\n          if (!this.isFocusGuard(visibleNodes[_ind]) && this.isFocusable(visibleNodes[_ind])) {\n            target = visibleNodes[_ind];\n            break;\n          }\n        }\n      }\n\n      if (target) {\n        target.focus();\n      } else {\n        // If no focusable element was found, blur the guard focus\n        guard.blur();\n      }\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible(element) {\n      return element.offsetWidth > 0 || element.offsetHeight > 0;\n    }\n  }, {\n    key: \"isFocusGuard\",\n    value: function isFocusGuard(element) {\n      return element.classList.contains(focusGuardClass);\n    }\n  }, {\n    key: \"isFocusable\",\n    value: function isFocusable(element) {\n      if (focusableNodes.indexOf(element.nodeName) > -1) {\n        return true;\n      }\n\n      if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n        if (element.getAttribute(\"disabled\")) {\n          return false;\n        }\n\n        return true;\n      }\n\n      var tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n\n      if (!isNaN(tabindex) && tabindex >= 0) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return FocusGuard;\n}();\n\nexport { FocusGuard as default };","map":{"version":3,"mappings":"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","names":["Keyboard","focusGuardClass","focusableNodes","focusableDisableableNodes","FocusGuard","container","_classCallCheck","guardedElement","element","releaseFocus","$","enable","trapFocus","guards","querySelectorAll","length","forEach","guard","dataset","position","_this","prepend","append","startGuard","createFocusGuard","endGuard","addEventListener","handleContainerFocus","remove","document","createElement","className","tabIndex","setAttribute","blur","visibleNodes","Array","from","filter","item","_this2","isVisible","target","ind","isFocusGuard","isFocusable","focus","offsetWidth","offsetHeight","classList","contains","indexOf","nodeName","getAttribute","tabindex","parseInt","isNaN"],"sources":["/home/agustibr/.asdf/installs/ruby/3.0.2/lib/ruby/gems/3.0.0/bundler/gems/decidim-a25b5c74f78d/decidim-core/app/packs/src/decidim/focus_guard.js"],"sourcesContent":["import { Keyboard } from \"foundation-sites\"\n\nconst focusGuardClass = \"focusguard\";\nconst focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nconst focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\n\nexport default class FocusGuard {\n  constructor(container) {\n    this.container = container;\n    this.guardedElement = null;\n  }\n\n  trap(element) {\n    if (this.guardedElement) {\n      Keyboard.releaseFocus($(this.guardedElement));\n    }\n\n    this.enable();\n    this.guardedElement = element;\n\n    // Call the release focus first so that we don't accidentally add the\n    // keyboard trap twice. Note that the Foundation methods expect the elements\n    // to be jQuery elements which is why we pass them through jQuery.\n    Keyboard.releaseFocus($(element));\n    Keyboard.trapFocus($(element));\n  }\n\n  enable() {\n    // Check if the guards already exists due to some other dialog\n    const guards = this.container.querySelectorAll(`:scope > .${focusGuardClass}`);\n    if (guards.length > 0) {\n      // Make sure the guards are the first and last element as there have\n      // been changes in the DOM.\n      guards.forEach((guard) => {\n        if (guard.dataset.position === \"start\") {\n          this.container.prepend(guard);\n        } else {\n          this.container.append(guard);\n        }\n      })\n\n      return;\n    }\n\n    // Add guards at the start and end of the document and attach their focus\n    // listeners\n    const startGuard = this.createFocusGuard(\"start\");\n    const endGuard = this.createFocusGuard(\"end\");\n\n    this.container.prepend(startGuard);\n    this.container.append(endGuard);\n\n    startGuard.addEventListener(\"focus\", () => this.handleContainerFocus(startGuard));\n    endGuard.addEventListener(\"focus\", () => this.handleContainerFocus(endGuard));\n  }\n\n  disable() {\n    const guards = this.container.querySelectorAll(`:scope > .${focusGuardClass}`);\n    guards.forEach((guard) => guard.remove());\n\n    if (this.guardedElement) {\n      // Note that the Foundation methods expect the elements to be jQuery\n      // elements which is why we pass them through jQuery.\n      Keyboard.releaseFocus($(this.guardedElement));\n      this.guardedElement = null;\n    }\n  }\n\n  createFocusGuard(position) {\n    const guard = document.createElement(\"div\");\n    guard.className = focusGuardClass;\n    guard.dataset.position = position;\n    guard.tabIndex = 0;\n    guard.setAttribute(\"aria-hidden\", \"true\");\n\n    return guard;\n  };\n\n  handleContainerFocus(guard) {\n    if (!this.guardedElement) {\n      guard.blur();\n      return;\n    }\n\n    const visibleNodes = Array.from(this.guardedElement.querySelectorAll(\"*\")).filter((item) => {\n      return this.isVisible(item);\n    });\n\n    let target = null;\n    if (guard.dataset.position === \"start\") {\n      // Focus at the start guard, so focus the first focusable element after that\n      for (let ind = 0; ind < visibleNodes.length; ind += 1) {\n        if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n          target = visibleNodes[ind];\n          break;\n        }\n      }\n    } else {\n      // Focus at the end guard, so focus the first focusable element after that\n      for (let ind = visibleNodes.length - 1; ind >= 0; ind -= 1) {\n        if (!this.isFocusGuard(visibleNodes[ind]) && this.isFocusable(visibleNodes[ind])) {\n          target = visibleNodes[ind];\n          break;\n        }\n      }\n    }\n\n    if (target) {\n      target.focus();\n    } else {\n      // If no focusable element was found, blur the guard focus\n      guard.blur();\n    }\n  };\n\n  isVisible(element) {\n    return element.offsetWidth > 0 || element.offsetHeight > 0;\n  }\n\n  isFocusGuard(element) {\n    return element.classList.contains(focusGuardClass);\n  }\n\n  isFocusable(element) {\n    if (focusableNodes.indexOf(element.nodeName) > -1) {\n      return true;\n    }\n    if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n      if (element.getAttribute(\"disabled\")) {\n        return false;\n      }\n      return true;\n    }\n\n    const tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n    if (!isNaN(tabindex) && tabindex >= 0) {\n      return true;\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}