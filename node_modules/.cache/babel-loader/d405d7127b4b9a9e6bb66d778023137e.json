{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar visitedPages = JSON.parse(sessionStorage.getItem(\"visitedPages\")) || [];\nvar userChoice = sessionStorage.getItem(\"userChoice\");\nvar DELAYED_VISITS = 2;\nvar deferredPrompt = null;\n\nvar shouldCountVisitedPages = function shouldCountVisitedPages() {\n  return userChoice !== \"dismissed\" && visitedPages.length < DELAYED_VISITS && !visitedPages.includes(location.pathname);\n};\n\nvar shouldPrompt = function shouldPrompt() {\n  return deferredPrompt && userChoice !== \"dismissed\" && visitedPages.length >= DELAYED_VISITS;\n};\n\nwindow.addEventListener(\"beforeinstallprompt\", function (event) {\n  deferredPrompt = event; // allow the user browse through different locations before prompt them anything\n\n  if (shouldCountVisitedPages()) {\n    sessionStorage.setItem(\"visitedPages\", JSON.stringify([].concat(_toConsumableArray(visitedPages), [location.pathname])));\n  }\n}); // to trigger the prompt, it must be a \"user gesture\"\n\nwindow.addEventListener(\"click\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n  var _yield$deferredPrompt, outcome;\n\n  return _regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!shouldPrompt()) {\n            _context.next = 8;\n            break;\n          }\n\n          deferredPrompt.prompt();\n          _context.next = 4;\n          return deferredPrompt.userChoice;\n\n        case 4:\n          _yield$deferredPrompt = _context.sent;\n          outcome = _yield$deferredPrompt.outcome; // store the user choice to avoid asking again in the current session\n\n          sessionStorage.setItem(\"userChoice\", outcome);\n          sessionStorage.removeItem(\"visitedPages\");\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n})));","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,YAAY,GAAGC,IAAI,CAACC,KAALD,CAAWE,cAAc,CAACC,OAAfD,CAAuB,cAAvBA,CAAXF,KAAsD,EAA3E;AACA,IAAMI,UAAU,GAAGF,cAAc,CAACC,OAAfD,CAAuB,YAAvBA,CAAnB;AACA,IAAMG,cAAc,GAAG,CAAvB;AACA,IAAIC,cAAc,GAAG,IAArB;;AAEA,IAAMC,uBAAuB,GAAG,SAA1BA,uBAA0B;EAAA,OAAMH,UAAU,KAAK,WAAfA,IAA8BL,YAAY,CAACS,MAAbT,GAAsBM,cAApDD,IAAsE,CAACL,YAAY,CAACU,QAAbV,CAAsBW,QAAQ,CAACC,QAA/BZ,CAA7E;AAAhC;;AACA,IAAMa,YAAY,GAAG,SAAfA,YAAe;EAAA,OAAMN,cAAc,IAAIF,UAAU,KAAK,WAAjCE,IAAgDP,YAAY,CAACS,MAAbT,IAAuBM,cAA7E;AAArB;;AAEAQ,MAAM,CAACC,gBAAPD,CAAwB,qBAAxBA,EAA+C,UAACE,KAAD,EAAW;EACxDT,cAAc,GAAGS,KAAjBT,CADwD,CAGxD;;EACA,IAAIC,uBAAuB,EAA3B,EAA+B;IAC7BL,cAAc,CAACc,OAAfd,CAAuB,cAAvBA,EAAuCF,IAAI,CAACiB,SAALjB,8BAAmBD,YAAnB,IAAiCW,QAAQ,CAACC,QAA1C,GAAvCT;EACD;AANH,G,CASA;;AACAW,MAAM,CAACC,gBAAPD,CAAwB,OAAxBA,wEAAiC;EAAA;;EAAA;IAAA;MAAA;QAAA;UAAA,KAC3BD,YAAY,EADe;YAAAM;YAAA;UAAA;;UAE7BZ,cAAc,CAACa,MAAfb;UAF6BY;UAAA,OAIHZ,cAAc,CAACF,UAJZ;;QAAA;UAAAgB;UAIrBC,OAJqB,yBAIrBA,QAJqB,CAM7B;;UACAnB,cAAc,CAACc,OAAfd,CAAuB,YAAvBA,EAAqCmB,OAArCnB;UACAA,cAAc,CAACoB,UAAfpB,CAA0B,cAA1BA;;QAR6B;QAAA;UAAA;MAAA;IAAA;EAAA;AAAjC","names":["visitedPages","JSON","parse","sessionStorage","getItem","userChoice","DELAYED_VISITS","deferredPrompt","shouldCountVisitedPages","length","includes","location","pathname","shouldPrompt","window","addEventListener","event","setItem","stringify","_context","prompt","_yield$deferredPrompt","outcome","removeItem"],"sources":["/home/agustibr/.asdf/installs/ruby/3.0.2/lib/ruby/gems/3.0.0/bundler/gems/decidim-a25b5c74f78d/decidim-core/app/packs/src/decidim/sw/a2hs.js"],"sourcesContent":["const visitedPages = JSON.parse(sessionStorage.getItem(\"visitedPages\")) || []\nconst userChoice = sessionStorage.getItem(\"userChoice\")\nconst DELAYED_VISITS = 2\nlet deferredPrompt = null\n\nconst shouldCountVisitedPages = () => userChoice !== \"dismissed\" && visitedPages.length < DELAYED_VISITS && !visitedPages.includes(location.pathname)\nconst shouldPrompt = () => deferredPrompt && userChoice !== \"dismissed\" && visitedPages.length >= DELAYED_VISITS\n\nwindow.addEventListener(\"beforeinstallprompt\", (event) => {\n  deferredPrompt = event\n\n  // allow the user browse through different locations before prompt them anything\n  if (shouldCountVisitedPages()) {\n    sessionStorage.setItem(\"visitedPages\", JSON.stringify([...visitedPages, location.pathname]))\n  }\n});\n\n// to trigger the prompt, it must be a \"user gesture\"\nwindow.addEventListener(\"click\", async () => {\n  if (shouldPrompt()) {\n    deferredPrompt.prompt()\n\n    const { outcome } = await deferredPrompt.userChoice;\n\n    // store the user choice to avoid asking again in the current session\n    sessionStorage.setItem(\"userChoice\", outcome)\n    sessionStorage.removeItem(\"visitedPages\")\n  }\n});\n"]},"metadata":{},"sourceType":"module"}